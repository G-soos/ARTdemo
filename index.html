<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taller de Canales ORM</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilo personalizado para los canvas para que no sean borrosos */
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background-color: #374151; /* bg-gray-700 */
        }
        /* Estilo para contenedores deshabilitados (Ahora solo se usa para opacidad visual) */
        .disabled-container {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex items-center justify-center min-h-screen p-4">

    <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-6xl">
        
        <h1 class="text-3xl font-bold text-center text-white mb-2">Taller de Canales ORM</h1>
        <p class="text-center text-lg text-gray-400 mb-8">Crea tu textura ORM (Occlusion, Roughness, Metallic)</p>

        <!-- Contenedor de Entradas de Canal -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            
            <!-- Canal ROJO (Occlusion) -->
            <div id="occlusionContainer" class="space-y-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700 transition duration-150">
                <h2 class="text-xl font-semibold text-red-400">Canal ROJO (R): Occlusion</h2>
                <label for="occlusionLoader" class="block w-full cursor-pointer bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-center transition duration-200 text-sm">
                    Cargar Mapa de Oclusión
                </label>
                <input type="file" id="occlusionLoader" class="hidden" accept="image/*">
                
                <!-- Área de Estado y Botón de Borrado -->
                <div id="redStatusArea" class="hidden flex items-center justify-between p-1 bg-red-900/30 rounded">
                    <div id="red-status" class="text-red-300 font-mono text-xs truncate"></div>
                    <button id="redClearButton" data-channel="r" class="text-red-300 hover:text-white bg-red-700/50 hover:bg-red-700 w-6 h-6 rounded-full flex items-center justify-center font-bold text-sm transition duration-150 ml-2" title="Eliminar textura">X</button>
                </div>

                <p id="redSolidLabel" class="text-xs text-gray-500 text-center">O usa un valor sólido:</p>
                
                <div id="redSliderContainer">
                    <label for="redChannel" class="block mb-1 text-sm sr-only">Valor de Oclusión</label>
                    <input id="redChannel" type="range" min="0" max="255" value="255" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-sm" style="accent-color: #f87171;">
                    <div class="text-center text-red-300 font-mono text-sm" id="redValueLabel">Valor: 255 (Blanco)</div>
                </div>
            </div>

            <!-- Canal VERDE (Roughness) -->
            <div id="roughnessContainer" class="space-y-4 p-4 bg-gray-900/50 rounded-lg border border-emerald-700 border-2 transition duration-150">
                <h2 class="text-xl font-semibold text-emerald-400">Canal VERDE (G): Roughness</h2>
                <label for="imageLoader" class="block w-full cursor-pointer bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg text-center transition duration-200 text-sm">
                    Cargar Mapa de Roughness
                </label>
                <input type="file" id="imageLoader" class="hidden" accept="image/*">
                
                <!-- Área de Estado y Botón de Borrado -->
                <div id="greenStatusArea" class="hidden flex items-center justify-between p-1 bg-emerald-900/30 rounded">
                    <div id="green-status" class="text-emerald-300 font-mono text-xs truncate"></div>
                    <button id="greenClearButton" data-channel="g" class="text-emerald-300 hover:text-white bg-emerald-700/50 hover:bg-emerald-700 w-6 h-6 rounded-full flex items-center justify-center font-bold text-sm transition duration-150 ml-2" title="Eliminar textura">X</button>
                </div>
                
                <p id="greenSolidLabel" class="text-xs text-gray-500 text-center">O usa un valor sólido:</p>

                <div id="greenSliderContainer">
                    <label for="greenChannel" class="block mb-1 text-sm sr-only">Valor de Roughness</label>
                    <input id="greenChannel" type="range" min="0" max="255" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-sm" style="accent-color: #34d399;">
                    <div class="text-center text-emerald-300 font-mono text-sm" id="greenValueLabel">Valor: 0 (Mate)</div>
                </div>
            </div>

            <!-- Canal AZUL (Metallic) -->
            <div id="metallicContainer" class="space-y-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700 transition duration-150">
                <h2 class="text-xl font-semibold text-blue-400">Canal AZUL (B): Metallic</h2>
                <label for="metallicLoader" class="block w-full cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg text-center transition duration-200 text-sm">
                    Cargar Mapa Metálico
                </label>
                <input type="file" id="metallicLoader" class="hidden" accept="image/*">
                
                <!-- Área de Estado y Botón de Borrado -->
                <div id="blueStatusArea" class="hidden flex items-center justify-between p-1 bg-blue-900/30 rounded">
                    <div id="blue-status" class="text-blue-300 font-mono text-xs truncate"></div>
                    <button id="blueClearButton" data-channel="b" class="text-blue-300 hover:text-white bg-blue-700/50 hover:bg-blue-700 w-6 h-6 rounded-full flex items-center justify-center font-bold text-sm transition duration-150 ml-2" title="Eliminar textura">X</button>
                </div>
                
                <p id="blueSolidLabel" class="text-xs text-gray-500 text-center">O usa un valor sólido:</p>
                
                <div id="blueSliderContainer">
                    <label for="blueChannel" class="block mb-1 text-sm sr-only">Valor Metálico</label>
                    <input id="blueChannel" type="range" min="0" max="255" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-sm" style="accent-color: #60a5fa;">
                    <div class="text-center text-blue-300 font-mono text-sm" id="blueValueLabel">Valor: 0 (Negro)</div>
                </div>
            </div>
        </div>
        
        <hr class="border-gray-700 mb-8">

        <!-- Contenedor Desplegable para Separador ORM (Splitter) -->
        <div id="splitterMainContainer" class="bg-gray-700 p-4 rounded-lg mb-8 transition duration-150 border border-gray-700">
            <button id="splitterToggle" class="w-full text-left py-2 text-lg font-semibold text-white flex justify-between items-center focus:outline-none">
                Desglosar Textura ORM Combinada (Splitter)
                <svg id="toggleIcon" class="w-5 h-5 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            
            <div id="splitterContent" class="hidden mt-4 pt-4 border-t border-gray-600">
                <!-- Zona de Carga y Estado del ORM a Desglosar -->
                <div id="splitterLoadArea" class="space-y-3 mb-6 p-4 bg-gray-900 rounded-lg border border-purple-500/50 transition duration-150">
                    <label for="ormSplitterLoader" id="splitterLabel" class="block w-full cursor-pointer bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg text-center transition duration-200 text-sm">
                        1. Cargar/Arrastrar Textura ORM (RGB)
                    </label>
                    <input type="file" id="ormSplitterLoader" class="hidden" accept="image/*">
                    
                    <!-- Área de Estado y Botón de Borrado del Splitter -->
                    <div id="splitterStatusArea" class="hidden flex items-center justify-between p-1 bg-purple-900/30 rounded">
                        <div id="splitter-status" class="text-purple-300 font-mono text-xs truncate"></div>
                        <button id="splitterClearButton" class="text-purple-300 hover:text-white bg-purple-700/50 hover:bg-purple-700 w-6 h-6 rounded-full flex items-center justify-center font-bold text-sm transition duration-150 ml-2" title="Eliminar textura ORM cargada">X</button>
                    </div>
                </div>

                <p id="splitterMessage" class="text-sm text-gray-400 mb-4">2. Arrastra y suelta la miniatura deseada al canal de arriba (Rojo, Verde o Azul).</p>
                
                <div id="splitterResults" class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                    <!-- ROJO (Occlusion) -->
                    <div id="splitRedContainer" class="p-2 border border-red-500 rounded-lg text-center cursor-grab bg-gray-900/50 hover:bg-gray-700 transition duration-150 shadow-md opacity-50 pointer-events-none" draggable="true" data-channel-name="occlusion">
                        <canvas id="splitRedCanvas" class="w-full aspect-square rounded mb-1 border border-gray-600"></canvas>
                        <span class="text-red-300 text-xs font-mono">Rojo (Occlusion)</span>
                    </div>
                    <!-- VERDE (Roughness) -->
                    <div id="splitGreenContainer" class="p-2 border border-emerald-500 rounded-lg text-center cursor-grab bg-gray-900/50 hover:bg-gray-700 transition duration-150 shadow-md opacity-50 pointer-events-none" draggable="true" data-channel-name="roughness">
                        <canvas id="splitGreenCanvas" class="w-full aspect-square rounded mb-1 border border-gray-600"></canvas>
                        <span class="text-emerald-300 text-xs font-mono">Verde (Roughness)</span>
                    </div>
                    <!-- AZUL (Metallic) -->
                    <div id="splitBlueContainer" class="p-2 border border-blue-500 rounded-lg text-center cursor-grab bg-gray-900/50 hover:bg-gray-700 transition duration-150 shadow-md opacity-50 pointer-events-none" draggable="true" data-channel-name="metallic">
                        <canvas id="splitBlueCanvas" class="w-full aspect-square rounded mb-1 border border-gray-600"></canvas>
                        <span class="text-blue-300 text-xs font-mono">Azul (Metallic)</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Fin del Contenedor Desplegable -->


        <!-- Contenedor de Salida -->
        <div id="outputContainer" class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
            
            <!-- Columna de Configuración de Salida -->
            <div class="space-y-6">
                <h2 class="text-xl font-semibold text-white">Configuración de Salida</h2>
                <div>
                    <label for="outputSize" class="block mb-2 text-sm font-medium text-gray-300">1. Definir Tamaño de Salida (Maestro)</label>
                    <select id="outputSize" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        <option id="originalSizeOption" value="original" disabled>Original (Cargar una imagen primero)</option>
                        <option value="4096">4096x4096</option>
                        <option value="2048">2048x2048</option>
                        <option value="1024" selected>1024x1024 (Defecto)</option>
                        <option value="512">512x512</option>
                        <option value="256">256x256</option>
                        <option value="128">128x128</option>
                        <option value="64">64x64</option>
                    </select>
                </div>
                
                <!-- BOTÓN DE DESCARGA: Habilitado siempre por valores sólidos -->
                <button id="downloadButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition duration-200">
                    2. Descargar Imagen ORM (.png)
                </button>
            </div>

            <!-- Columna de Vista Previa de Salida -->
            <div>
                <h3 class="text-lg font-semibold mb-2 text-center">Salida (Tu ORM)</h3>
                <canvas id="outputCanvas" class="w-full aspect-square rounded-lg border-2 border-gray-700"></canvas>
            </div>
        </div>

    </div>

    <!-- Canvas ocultos para procesamiento -->
    <canvas id="hiddenRedCanvas" class="hidden"></canvas>
    <canvas id="hiddenGreenCanvas" class="hidden"></canvas>
    <canvas id="hiddenBlueCanvas" class="hidden"></canvas>
    <canvas id="processingCanvas" class="hidden"></canvas>
    <canvas id="hiddenSplitCanvas" class="hidden"></canvas> <!-- Canvas oculto dedicado para la separación -->

    <script>
        // --- UTILIDAD: Función de Debounce ---
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // --- Obtener Elementos del DOM ---
        const imageLoader = document.getElementById('imageLoader'); 
        const occlusionLoader = document.getElementById('occlusionLoader'); 
        const metallicLoader = document.getElementById('metallicLoader'); 

        const redChannel = document.getElementById('redChannel');
        const greenChannel = document.getElementById('greenChannel');
        const blueChannel = document.getElementById('blueChannel');
        
        const redValueLabel = document.getElementById('redValueLabel');
        const greenValueLabel = document.getElementById('greenValueLabel');
        const blueValueLabel = document.getElementById('blueValueLabel');
        
        // Status Labels y Botones de Limpieza
        const redStatus = document.getElementById('red-status');
        const greenStatus = document.getElementById('green-status');
        const blueStatus = document.getElementById('blue-status');

        const redStatusArea = document.getElementById('redStatusArea');
        const greenStatusArea = document.getElementById('greenStatusArea');
        const blueStatusArea = document.getElementById('blueStatusArea');
        
        const redClearButton = document.getElementById('redClearButton');
        const greenClearButton = document.getElementById('greenClearButton');
        const blueClearButton = document.getElementById('blueClearButton');

        const redSolidLabel = document.getElementById('redSolidLabel');
        const greenSolidLabel = document.getElementById('greenSolidLabel');
        const blueSolidLabel = document.getElementById('blueSolidLabel');
        
        const outputSize = document.getElementById('outputSize');
        const originalSizeOption = document.getElementById('originalSizeOption');
        
        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');

        // Contenedores de Sliders para control de estado visual
        const redSliderContainer = document.getElementById('redSliderContainer');
        const greenSliderContainer = document.getElementById('greenSliderContainer');
        const blueSliderContainer = document.getElementById('blueSliderContainer');


        // Contextos de canvas ocultos
        const hiddenRedCtx = document.getElementById('hiddenRedCanvas').getContext('2d');
        const hiddenGreenCtx = document.getElementById('hiddenGreenCanvas').getContext('2d');
        const hiddenBlueCtx = document.getElementById('hiddenBlueCanvas').getContext('2d');
        const processingCanvas = document.getElementById('processingCanvas');
        const processingCtx = processingCanvas.getContext('2d');
        
        const downloadButton = document.getElementById('downloadButton');

        // NEW: Splitter elements
        const splitterToggle = document.getElementById('splitterToggle');
        const splitterContent = document.getElementById('splitterContent');
        const toggleIcon = document.getElementById('toggleIcon');
        const ormSplitterLoader = document.getElementById('ormSplitterLoader');
        const hiddenSplitCanvas = document.getElementById('hiddenSplitCanvas');
        const hiddenSplitCtx = hiddenSplitCanvas.getContext('2d');
        const splitRedCanvas = document.getElementById('splitRedCanvas');
        const splitGreenCanvas = document.getElementById('splitGreenCanvas');
        const splitBlueCanvas = document.getElementById('splitBlueCanvas');
        const splitRedCtx = splitRedCanvas.getContext('2d');
        const splitGreenCtx = splitGreenCanvas.getContext('2d');
        const splitBlueCtx = splitBlueCanvas.getContext('2d');
        const splitRedContainer = document.getElementById('splitRedContainer');
        const splitGreenContainer = document.getElementById('splitGreenContainer');
        const splitBlueContainer = document.getElementById('splitBlueContainer');
        const splitterLoadArea = document.getElementById('splitterLoadArea'); // Para Drag & Drop
        const splitterStatusArea = document.getElementById('splitterStatusArea');
        const splitterStatus = document.getElementById('splitter-status');
        const splitterClearButton = document.getElementById('splitterClearButton');
        const splitterLabel = document.getElementById('splitterLabel');

        // Almacenamiento de imágenes, estado y nombre de archivo
        const images = {
            r: new Image(),
            g: new Image(),
            b: new Image()
        };
        const loadState = { r: false, g: false, b: false, splitter: false }; // Añadir estado del splitter
        const filenames = { r: '', g: '', b: '', splitter: '' }; // Añadir nombre del splitter
        const splitterImg = new Image(); // Imagen fuente del splitter

        let originalImageSize = { w: 0, h: 0 };


        // --- Lógica de Manejo de Carga Genérica (Para input[type=file] y drag-and-drop) ---
        function handleImageLoad(imageObj, stateKey, hiddenCtx, statusArea, statusElement, sliderInput, sliderContainer, width, height, filename) {
            
            // Si es la primera imagen cargada en la aplicación, actualizamos el tamaño original.
            if (!loadState.r && !loadState.g && !loadState.b) {
                originalImageSize.w = width;
                originalImageSize.h = height;
            } else if (width > originalImageSize.w) { // Elegir el tamaño más grande si se carga una imagen mayor.
                originalImageSize.w = width;
                originalImageSize.h = height;
            }
            
            // Actualizar la opción 'Original'
            originalSizeOption.text = `Original (${originalImageSize.w}x${originalImageSize.h}px)`;
            originalSizeOption.disabled = false;
            
            loadState[stateKey] = true;
            filenames[stateKey] = filename; 
            
            // Determinar el label "O usa un valor sólido:"
            const solidLabelId = stateKey + 'SolidLabel';
            const solidLabel = document.getElementById(solidLabelId);
            
            // Actualizar estado visual
            if (statusElement) {
                // Truncar nombre del archivo para que no desborde (máx 25 caracteres)
                const displayFilename = filename.length > 25 ? filename.substring(0, 22) + '...' : filename;
                statusElement.textContent = `Cargado: ${displayFilename}`;
                statusArea.classList.remove('hidden'); // Mostrar área de estado 
            }
            
            if (solidLabel) {
                solidLabel.classList.add('hidden'); // Ocultar "O usa un valor sólido:"
            }

            // Desactivar el slider para este canal
            if (sliderInput) {
                sliderInput.disabled = true;
                sliderContainer.classList.add('opacity-50');
            }

            // Redibujar el canvas oculto para la imagen original (escala 1:1)
            hiddenCtx.canvas.width = width;
            hiddenCtx.canvas.height = height;
            hiddenCtx.drawImage(imageObj, 0, 0, width, height);
            
            processImage(); // Ejecución inmediata al cargar una imagen
        }

        function createChannelLoadHandler(imageObj, stateKey, hiddenCtx, statusArea, statusElement, sliderInput, sliderContainer) {
            return function(event) {
                const file = event.target.files[0];
                if (!file) return;

                const url = URL.createObjectURL(file);
                imageObj.src = url;
                imageObj.onload = () => {
                    handleImageLoad(imageObj, stateKey, hiddenCtx, statusArea, statusElement, sliderInput, sliderContainer, imageObj.width, imageObj.height, file.name); 
                };
            };
        }
        
        // Asignar manejadores a los 3 canales (Input File)
        occlusionLoader.addEventListener('change', createChannelLoadHandler(images.r, 'r', hiddenRedCtx, redStatusArea, redStatus, redChannel, redSliderContainer));
        imageLoader.addEventListener('change', createChannelLoadHandler(images.g, 'g', hiddenGreenCtx, greenStatusArea, greenStatus, greenChannel, greenSliderContainer));
        metallicLoader.addEventListener('change', createChannelLoadHandler(images.b, 'b', hiddenBlueCtx, blueStatusArea, blueStatus, blueChannel, blueSliderContainer));


        // --- Lógica de Drag and Drop para Canales de Empaquetado ---
        function setupPackerDragAndDrop(containerId, imageObj, stateKey, hiddenCtx, statusArea, statusElement, sliderInput, sliderContainer) {
            const container = document.getElementById(containerId);
            const originalBorderClass = container.classList.contains('border-emerald-700') ? 'border-emerald-700' : 'border-gray-700';
            
            // 1. Prevenir comportamiento por defecto y añadir feedback visual
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                const isSplitChannel = e.dataTransfer.types.includes('application/x-split-channel');
                
                if (e.dataTransfer.files.length > 0 || isSplitChannel) {
                    container.classList.add('border-dashed', 'border-4', 'border-blue-400');
                    container.classList.remove(originalBorderClass);
                    e.dataTransfer.dropEffect = 'copy';
                }
            });

            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                container.classList.remove('border-dashed', 'border-4', 'border-blue-400');
                container.classList.add(originalBorderClass);
            });
            
            // 2. Manejar el evento drop
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                container.classList.remove('border-dashed', 'border-4', 'border-blue-400');
                container.classList.add(originalBorderClass);
                
                // --- A. Handle Split Channel Drop ---
                const splitChannelId = e.dataTransfer.getData('text/plain');
                const isSplitChannelDrop = e.dataTransfer.types.includes('application/x-split-channel');

                if (isSplitChannelDrop && splitChannelId) {
                    const splitContainer = document.getElementById(splitChannelId);
                    const sourceCanvas = splitContainer ? splitContainer.querySelector('canvas') : null;
                    
                    if (sourceCanvas && sourceCanvas.dataset.fullDataUrl) {
                        const url = sourceCanvas.dataset.fullDataUrl;
                        const w = parseInt(sourceCanvas.dataset.originalWidth);
                        const h = parseInt(sourceCanvas.dataset.originalHeight);
                        const filename = `SPLIT_${splitContainer.dataset.channelName.toUpperCase()}_${w}.png`; // Crear un nombre único

                        imageObj.src = url;
                        imageObj.onload = () => {
                            handleImageLoad(imageObj, stateKey, hiddenCtx, statusArea, statusElement, sliderInput, sliderContainer, w, h, filename);
                        };
                        return; // Salir si un canal separado fue manejado
                    }
                }

                // --- B. Handle External File Drop (Original Logic) ---
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const url = URL.createObjectURL(file);
                    
                    imageObj.src = url;
                    imageObj.onload = () => {
                        handleImageLoad(imageObj, stateKey, hiddenCtx, statusArea, statusElement, sliderInput, sliderContainer, imageObj.width, imageObj.height, file.name); 
                    };
                } else if (!isSplitChannelDrop) { 
                    if (statusElement) {
                         statusElement.textContent = `Error: Archivo no válido.`;
                         statusArea.classList.remove('hidden'); 
                         setTimeout(() => statusArea.classList.add('hidden'), 3000); 
                    }
                }
            });
        }
        
        // Asignar manejadores Drag and Drop a los 3 contenedores
        setupPackerDragAndDrop('occlusionContainer', images.r, 'r', hiddenRedCtx, redStatusArea, redStatus, redChannel, redSliderContainer);
        setupPackerDragAndDrop('roughnessContainer', images.g, 'g', hiddenGreenCtx, greenStatusArea, greenStatus, greenChannel, greenSliderContainer);
        setupPackerDragAndDrop('metallicContainer', images.b, 'b', hiddenBlueCtx, blueStatusArea, blueStatus, blueChannel, blueSliderContainer);

        // --- Lógica de Drag Start para Split Results ---
        [splitRedContainer, splitGreenContainer, splitBlueContainer].forEach(container => {
            container.addEventListener('dragstart', (e) => {
                const canvas = container.querySelector('canvas');
                if (!canvas.dataset.fullDataUrl) {
                    e.preventDefault();
                    return;
                }
                e.dataTransfer.setData('text/plain', container.id);
                e.dataTransfer.setData('application/x-split-channel', 'true');
                e.dataTransfer.effectAllowed = 'copy';
                
                // Imagen fantasma
                if (canvas.width > 0) {
                    e.dataTransfer.setDragImage(canvas, canvas.width / 2, canvas.height / 2);
                }
            });

            container.addEventListener('dragend', (e) => {
                const canvas = container.querySelector('canvas');
                if (!canvas.dataset.fullDataUrl) {
                    e.preventDefault();
                }
            });
        });


        // --- Lógica para Eliminar Textura (Borrado de Canales) ---
        function clearChannel(stateKey) {
            
            const dataMap = {
                r: { ctx: hiddenRedCtx, statusArea: redStatusArea, slider: redChannel, sliderContainer: redSliderContainer, solidLabel: redSolidLabel },
                g: { ctx: hiddenGreenCtx, statusArea: greenStatusArea, slider: greenChannel, sliderContainer: greenSliderContainer, solidLabel: greenSolidLabel },
                b: { ctx: hiddenBlueCtx, statusArea: blueStatusArea, slider: blueChannel, sliderContainer: blueSliderContainer, solidLabel: blueSolidLabel }
            };

            const { ctx, statusArea, slider, sliderContainer, solidLabel } = dataMap[stateKey];

            // 1. Resetear estado
            loadState[stateKey] = false;
            filenames[stateKey] = '';

            // 2. Limpiar el canvas oculto 
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.canvas.width = 1; 
            ctx.canvas.height = 1;

            // 3. Ocultar status y mostrar label sólido
            statusArea.classList.add('hidden');
            solidLabel.classList.remove('hidden');

            // 4. Re-habilitar slider
            slider.disabled = false;
            sliderContainer.classList.remove('opacity-50');

            // 5. Verificar si se debe resetear el tamaño original
            const anyImageLoaded = loadState.r || loadState.g || loadState.b;
            if (!anyImageLoaded) {
                 originalImageSize = { w: 0, h: 0 };
                 originalSizeOption.text = `Original (Cargar una imagen primero)`;
                 originalSizeOption.disabled = true;
                 outputSize.value = "1024"; // Resetear al tamaño por defecto
            }

            // 6. Reprocesar la imagen
            processImage(); 
        }
        
        // Asignar manejadores a los botones de limpieza de canales de empaquetado
        redClearButton.addEventListener('click', () => clearChannel('r'));
        greenClearButton.addEventListener('click', () => clearChannel('g'));
        blueClearButton.addEventListener('click', () => clearChannel('b'));

        // --- Debounce y Lógica de Sliders/Tamaño ---
        
        const debouncedProcessImage = debounce(processImage, 50);

        redChannel.addEventListener('input', () => {
            redValueLabel.textContent = `Valor: ${redChannel.value} (${redChannel.value > 128 ? 'Blanco' : 'Negro'})`;
            debouncedProcessImage();
        });
        
        greenChannel.addEventListener('input', () => {
            greenValueLabel.textContent = `Valor: ${greenChannel.value} (${greenChannel.value > 128 ? 'Brillante' : 'Mate'})`;
            debouncedProcessImage();
        });

        blueChannel.addEventListener('input', () => {
            blueValueLabel.textContent = `Valor: ${blueChannel.value} (${blueChannel.value > 128 ? 'Blanco' : 'Negro'})`;
            debouncedProcessImage();
        });

        outputSize.addEventListener('input', debouncedProcessImage);


        // --- Lógica del Splitter ---

        // Toggle (Desplegable)
        splitterToggle.addEventListener('click', () => {
            const isHidden = splitterContent.classList.toggle('hidden');
            toggleIcon.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(180deg)';
        });

        // ----------------------------------------------------
        // Lógica de Carga y Drag&Drop para el ORM Splitter (Nuevo)
        // ----------------------------------------------------

        // A. Carga por Input File
        ormSplitterLoader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            splitterImg.src = url;
            splitterImg.onload = () => {
                handleSplitterLoad(splitterImg, file.name);
                URL.revokeObjectURL(url); 
            };
        });
        
        // B. Carga por Drag & Drop
        splitterLoadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                splitterLoadArea.classList.add('border-dashed', 'border-4', 'border-blue-400');
                e.dataTransfer.dropEffect = 'copy';
            }
        });

        splitterLoadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            splitterLoadArea.classList.remove('border-dashed', 'border-4', 'border-blue-400');
        });

        splitterLoadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            splitterLoadArea.classList.remove('border-dashed', 'border-4', 'border-blue-400');
            
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const url = URL.createObjectURL(file);
                splitterImg.src = url;
                splitterImg.onload = () => {
                    handleSplitterLoad(splitterImg, file.name);
                    URL.revokeObjectURL(url); 
                };
            }
        });

        // C. Función Manejadora de Carga de Splitter
        function handleSplitterLoad(img, filename) {
            loadState.splitter = true;
            filenames.splitter = filename;

            // Actualizar interfaz
            const displayFilename = filename.length > 25 ? filename.substring(0, 22) + '...' : filename;
            splitterStatus.textContent = `Cargado: ${displayFilename}`;
            splitterStatusArea.classList.remove('hidden');
            splitterLabel.classList.add('hidden'); // Ocultar el botón de carga

            // Habilitar miniaturas arrastrables
            [splitRedContainer, splitGreenContainer, splitBlueContainer].forEach(container => {
                container.classList.remove('opacity-50', 'pointer-events-none');
            });
            
            // Ejecutar la separación
            splitOrmImage(img);
        }

        // D. Función de Borrado del Splitter
        splitterClearButton.addEventListener('click', clearSplitter);

        function clearSplitter() {
            loadState.splitter = false;
            filenames.splitter = '';

            // Limpiar canvas oculto y previews
            hiddenSplitCtx.clearRect(0, 0, hiddenSplitCanvas.width, hiddenSplitCanvas.height);
            hiddenSplitCanvas.width = 1;
            hiddenSplitCanvas.height = 1;
            
            [splitRedCtx, splitGreenCtx, splitBlueCtx].forEach(ctx => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            });
            
            [splitRedCanvas, splitGreenCanvas, splitBlueCanvas].forEach(canvas => {
                delete canvas.dataset.fullDataUrl;
            });

            // Resetear interfaz
            splitterStatusArea.classList.add('hidden');
            splitterLabel.classList.remove('hidden');
            
            // Deshabilitar miniaturas arrastrables
            [splitRedContainer, splitGreenContainer, splitBlueContainer].forEach(container => {
                container.classList.add('opacity-50', 'pointer-events-none');
            });
        }


        // E. Función de Desglosar (Split)
        function splitOrmImage(img) {
            const w = img.width;
            const h = img.height;
            
            // 1. Dibujar la imagen de origen
            hiddenSplitCanvas.width = w;
            hiddenSplitCanvas.height = h;
            hiddenSplitCtx.drawImage(img, 0, 0);
            
            const imageData = hiddenSplitCtx.getImageData(0, 0, w, h);
            const data = imageData.data;
            const length = data.length;

            // 2. Crear datos de imagen para los 3 canales
            const redImageData = hiddenSplitCtx.createImageData(w, h);
            const greenImageData = hiddenSplitCtx.createImageData(w, h);
            const blueImageData = hiddenSplitCtx.createImageData(w, h);

            const redData = redImageData.data;
            const greenData = greenImageData.data;
            const blueData = blueImageData.data;

            // 3. Iterar y separar los canales
            for (let i = 0; i < length; i += 4) {
                // R (Occlusion)
                redData[i + 0] = data[i + 0]; 
                redData[i + 1] = data[i + 0]; // Grayscale
                redData[i + 2] = data[i + 0]; // Grayscale
                redData[i + 3] = 255;

                // G (Roughness)
                greenData[i + 0] = data[i + 1]; // Grayscale
                greenData[i + 1] = data[i + 1]; 
                greenData[i + 2] = data[i + 1]; // Grayscale
                greenData[i + 3] = 255;

                // B (Metallic)
                blueData[i + 0] = data[i + 2]; // Grayscale
                blueData[i + 1] = data[i + 2]; // Grayscale
                blueData[i + 2] = data[i + 2]; 
                blueData[i + 3] = 255;
            }

            // 4. Dibujar vistas previas y generar DataURLs de alta resolución
            const previewSize = 96;

            [splitRedCanvas, splitGreenCanvas, splitBlueCanvas].forEach(canvas => {
                canvas.width = previewSize; 
                canvas.height = previewSize;
            });

            function drawSplitPreview(sourceImageData, previewCtx) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = w;
                tempCanvas.height = h;
                tempCtx.putImageData(sourceImageData, 0, 0);
                
                previewCtx.imageSmoothingEnabled = false;
                previewCtx.drawImage(tempCanvas, 0, 0, w, h, 0, 0, previewCtx.canvas.width, previewCtx.canvas.height);
            }
            
            // Dibujar las miniaturas
            drawSplitPreview(redImageData, splitRedCtx);
            drawSplitPreview(greenImageData, splitGreenCtx);
            drawSplitPreview(blueImageData, splitBlueCtx);
            
            // 5. Almacenar DataURL de alta resolución y tamaño original para el Drag-and-Drop
            function getFullResDataUrl(imageData, w, h) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = w;
                tempCanvas.height = h;
                tempCtx.putImageData(imageData, 0, 0);
                return tempCanvas.toDataURL('image/png');
            }
            
            splitRedCanvas.dataset.fullDataUrl = getFullResDataUrl(redImageData, w, h);
            splitGreenCanvas.dataset.fullDataUrl = getFullResDataUrl(greenImageData, w, h);
            splitBlueCanvas.dataset.fullDataUrl = getFullResDataUrl(blueImageData, w, h);

            [splitRedCanvas, splitGreenCanvas, splitBlueCanvas].forEach(canvas => {
                canvas.dataset.originalWidth = w;
                canvas.dataset.originalHeight = h;
            });
        }


        // 6. Función principal de procesamiento (sin cambios)
        function processImage() {
            // Obtener el tamaño de salida deseado (Este es el tamaño MAESTRO de la textura ORM)
            let targetWidth, targetHeight;
            const sizeValue = outputSize.value;
            
            if (sizeValue === 'original' && originalImageSize.w > 0) {
                targetWidth = originalImageSize.w;
                targetHeight = originalImageSize.h;
            } else if (sizeValue === 'original' && originalImageSize.w === 0) {
                 // Si 'Original' está seleccionado pero no hay imagen cargada, usamos el valor por defecto
                targetWidth = 1024;
                targetHeight = 1024;
            } else {
                targetWidth = parseInt(sizeValue);
                targetHeight = parseInt(sizeValue);
            }

            // --- A. Ajustar y Redibujar Imágenes de Entrada al Tamaño Maestro ---
            
            processingCanvas.width = targetWidth;
            processingCanvas.height = targetHeight;
            
            // Creamos canvases temporales para dibujar la imagen original escalada.
            function redrawScaledChannel(sourceCtx, targetWidth, targetHeight) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = targetWidth;
                tempCanvas.height = targetHeight;

                if (sourceCtx.canvas.width > 1) { // Solo si hay imagen cargada
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(sourceCtx.canvas, 0, 0, sourceCtx.canvas.width, sourceCtx.canvas.height, 0, 0, targetWidth, targetHeight);
                }
                return tempCtx.getImageData(0, 0, targetWidth, targetHeight).data;
            }
            
            const redPixels = redrawScaledChannel(hiddenRedCtx, targetWidth, targetHeight);
            const greenPixels = redrawScaledChannel(hiddenGreenCtx, targetWidth, targetHeight);
            const bluePixels = redrawScaledChannel(hiddenBlueCtx, targetWidth, targetHeight);
            
            // --- B. Obtener datos finales para el empaquetado ---
            
            // Obtener valores de slider como fallback (para canales sin imagen cargada)
            const redValue = parseInt(redChannel.value);
            const greenValue = parseInt(greenChannel.value);
            const blueValue = parseInt(blueChannel.value);

            // Crear datos de imagen para la salida ORM
            const outputImageData = processingCtx.createImageData(targetWidth, targetHeight);
            const outputPixels = outputImageData.data;

            const totalPixels = targetWidth * targetHeight;

            // Iterar y empaquetar canales (4 bytes por píxel: R, G, B, A)
            for (let i = 0; i < totalPixels * 4; i += 4) {
                // R (Occlusion): Si hay imagen (canvas > 1x1), usa el canal R. Si no, usa el valor del slider.
                const r = loadState.r ? redPixels[i + 0] : redValue; 

                // G (Roughness): Si hay imagen, usa el canal R. Si no, usa el valor del slider.
                const g = loadState.g ? greenPixels[i + 0] : greenValue; 

                // B (Metallic): Si hay imagen, usa el canal R. Si no, usa el valor del slider.
                const b = loadState.b ? bluePixels[i + 0] : blueValue;


                outputPixels[i + 0] = r;   // Canal Rojo (Occlusion)
                outputPixels[i + 1] = g;   // Canal Verde (Roughness)
                outputPixels[i + 2] = b;   // Canal Azul (Metallic)
                outputPixels[i + 3] = 255; // Canal Alfa (Opacidad total)
            }
            
            // Poner los datos combinados en el canvas de procesamiento
            processingCtx.putImageData(outputImageData, 0, 0);

            // --- C. Dibujar resultado final en el canvas de salida visible ---

            outputCanvas.width = targetWidth;
            outputCanvas.height = targetHeight;
            outputCtx.imageSmoothingEnabled = false;

            outputCtx.drawImage(
                processingCanvas, 
                0, 0, targetWidth, targetHeight, 
                0, 0, targetWidth, targetHeight  
            );
        }

        // 7. Lógica de Descarga
        downloadButton.addEventListener('click', () => {
            const dataURL = outputCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `ORM_Texture_${outputCanvas.width}x${outputCanvas.height}.png`;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Inicializar el canvas al cargar
        processImage();

    </script>
</body>
</html>
